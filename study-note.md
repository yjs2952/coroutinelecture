## 섹션 2
### 스레드 기반 작업의 한계와 코루틴의 등장

### 단일 스레드 애플리케이션의 한계와 멀티 스레드 프로그래밍
- 스레드 하나만 사용해 실행하는 애플리케이션
- 한번에 하나의 작업 밖에 수행 못함

### 스레드, 스레드 풀을 사용한 멀티 스레드 프로그래밍 
- Thread 클래스를 직접 사용한 멀티 스레드 프로그래밍의 한계
  - Thread 의 start 함수를 호출할 때 마다 새로운 스레드가 생성되고 재사용이 어려움
- 개발자가 스레드 생성과 관리에 대해 책임을 가진다.
  - 개발자의 실수나 오류로 인해 메모리 누수가 발생할 수 있음
  - 프로그램이 복잡해질 수록 스레드의 생성과 관리를 직접 하는게 매우 어려움
- Executor 프레임웍
  - 스레드의 집합인 스레드풀을 미리 생성하고, 작업을 요청 받으면 쉬고 있는 스레드에 작업을 분배할 수 있는 시스템
- CompletableFuture
  - 콜백 지옥 발생
### 스레드 기반 작업을 사용하는 방식의 한계와 코루틴의 등장
- 코루틴이라는 작업 단위
- 코루틴은 스레드와 달리 실행 중에 중단하고 다시 시작할 수 있는 있음
- 경량 스레드

## 섹션 3

### CoroutineDispatcher
- 디스패처는 보내는 주체 따라서 코루틴 디스패처는 코루틴을 쓰레드로 보내 실행시키는 주체

### CoroutineDispatcher 종류
- Dispatchers.IO
  - 네트워크나 DB 작업 같은 입출력(I/O) 작업을 실행하는 디스패처 
  - 약 64개 스레드
  - limitedParallelism 함수를 사용하면 공유 스레드풀의 별도 스레드 중 일부를 사용
- Dispatchers.Default
  - CPU 바운드 작업을 위한 디스패처
    - 이미지, 동영상 처리나 대용량 데이터 변환 같은 끊이지 않고 연산이 필요한 작업
  - limitedParallelism 함수를 사용하면 Dispatcher.Default 스레드 중 일부를 사용하는 CoroutineDispatcher를 반환
- Dispatchers.Main
  - main 스레드에서의 작업을 위한 디스패처
  - 기본 코루틴 라이브러리에는 구현체가 없다 (안드로이드 라이브러리 필요)
  - Dispatchers.Main.immediate
    - main 스레드에서 실행되는 코루틴을 즉시 실행할 수 있는 디스패처
    - 코루틴을 요청하는 스레드가 메인 스레드일 경우 작업 대기열에 적재되지 않고 바로 메인 스레드에서 실행
      - 안드로이드 UI 에 바로 반영이 되어 메인 디스패처 사용 시 권장됨

[//]: # (    - main 스레드가 아닌 다른 스레드에서 호출하면, main 스레드가 준비될 때까지 대기)

## 섹션 4
### 코루틴 Job 순차 처리
- join, joinAll 함수를 활용하여 작업이 끝날 때 까지 대기 


